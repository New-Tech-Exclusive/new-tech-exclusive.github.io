<!DOCTYPE html>
<html lang="en">
<script src="https://cdn.jsdelivr.net/npm/htmx.org@2.0.8/dist/htmx.min.js"></script>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bentley's Portfolio | SPE</title>
    <link rel="stylesheet" href="style.css">
    <meta name="description" content="SPE Project Page - Synthetic Pathfinding Engine">
</head>

<body>
    <div class="bg-glow">
        <div class="glow-1"></div>
        <div class="glow-2"></div>
    </div>

    <div class="container">
        <header>
            <div class="reveal">
                <p class="subtitle">&lt; /creations_portfolio/SPE/ &gt;</p>
                <h1 class="hero-title">SPE.</h1>
                <p class="project-desc" style="max-width: 600px; font-size: 1.1rem;">
                    Synthetic Pathfinding Engine: A Neuro-Symbolic Approach to Language and Reasoning.
                </p>
            </div>
        </header>

        <section class="reveal">
            <h2 class="mono-stat" style="color: var(--accent-secondary); margin-top: 2rem;">[SYSTEM_OVERVIEW]</h2>
            <p class="project-desc" style="font-size: 1.1rem; margin-bottom: 2rem;">
                SPE is not another Transformer. It is a <b>Graph-Native Language Model</b> that treats knowledge as a geometric space and reasoning as a navigation problem. By combining the linguistic intuition of Small Language Models (SLMs) with the absolute logic of a Scalable Knowledge Graph, SPE achieves what traditional LLMs struggle with: 100% explainability and zero hallucinations.
            </p>
        </section>

        <div class="projects-grid" style="grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); margin-top: 2rem;">
            <div class="card reveal delay-1">
                <h3 style="color: var(--accent-emerald);">Neuro-Symbolic Hybrid</h3>
                <p class="project-desc">
                    SPE uses a "Dual-Pilot" system. A neural parser (like phi3) handles the messy nature of human input, while a symbolic engine performs the actual reasoning. This prevents the "black box" problem found in most AI.
                </p>
            </div>
            <div class="card reveal delay-2">
                <h3 style="color: var(--accent-primary);">A* Pathfinding</h3>
                <p class="project-desc">
                    Instead of predicting the next token based on probabilities, SPE finds the most logical path between concepts using A* search. Reasoning is a mathematical proof, not a guess.
                </p>
            </div>
            <div class="card reveal delay-3">
                <h3 style="color: var(--accent-secondary);">Native Generation</h3>
                <p class="project-desc">
                    SPE can generate text directly from its graph structure. It "speaks" by traversing linguistic nodes, allowing for extreme speed and efficiency without the need for massive Transformer inference.
                </p>
            </div>
        </div>

        <section class="reveal" style="margin-top: 4rem;">
            <h2 class="mono-stat" style="color: var(--accent-emerald);">[CORE_DIFFERENCES]</h2>
            <div style="background: var(--glass-bg); padding: 2rem; border-radius: 24px; border: 1px solid var(--glass-border); margin-top: 1rem;">
                <p class="project-desc" style="color: #fff; margin-bottom: 1rem;">
                    <b>Traditional LLMs:</b> Probability-based, resource-heavy, prone to hallucination, difficult to audit.
                </p>
                <p class="project-desc" style="color: var(--accent-emerald);">
                    <b>SPE Architecture:</b> Logic-based, edge-compute friendly, hallucination-impossible, fully explainable.
                </p>
            </div>
        </section>

        <section class="reveal" style="margin-top: 4rem;">
            <h2 class="mono-stat" style="color: var(--accent-primary);">[EXPLAINABILITY_TRACE]</h2>
            <div style="font-family: 'Roboto Mono', monospace; font-size: 0.9rem; background: #000; padding: 1.5rem; border-radius: 12px; color: #0f0; border: 1px solid #333;">
                <span style="color: #666;">// Reasoning Trace for "Force and Energy"</span><br>
                [input_extraction] concepts: {force, energy}<br>
                [pathfinding_init] heuristic: semantic_distance<br>
                [traverse] force -> kinetic_energy (0.85)<br>
                [traverse] kinetic_energy -> energy (1.0)<br>
                [native_gen] "Force leads to kinetic energy, which is a type of energy."
            </div>
        </section>
        <section class="reveal">
            <h2 class="mono-stat" style="color: var(--accent-secondary); margin-top: 2rem;">[ISSUES]</h2>
            <p class="project-desc" style="font-size: 1.1rem; margin-bottom: 2rem;">
                Due to the nature of having a model that doesn't fully rely on neural networks, some repsonses may feel less "fluent." <br>
                Some more creative things, like poetry, may feel more robotic, as I designed the AI itself to give reliable, factual, direct answers, over more creative ones. <br>
                However, this AI is NOWHERE near finished, I'm designing it to make SLM's more reliable, and until it can beat ChatGPT-3.5 in a full test, it won't be considered "done."
            </p>
        </section>

        <footer class="footer">
            <p>&copy; 2026 Bentley Robertson. The path is the logic. <br>
                <a href="index.html">Back to Portfolio</a>
            </p>
        </footer>
    </div>
    <script>
        // Simple Intersection Observer for reveal animations
        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    entry.target.style.opacity = '1';
                    entry.target.style.transform = 'translateY(0)';
                }
            });
        }, { threshold: 0.1 });

        document.querySelectorAll('.reveal').forEach(el => {
            el.style.opacity = '0';
            el.style.transform = 'translateY(20px)';
            el.style.transition = 'all 0.8s cubic-bezier(0.4, 0, 0.2, 1)';
            observer.observe(el);
        });
    </script>